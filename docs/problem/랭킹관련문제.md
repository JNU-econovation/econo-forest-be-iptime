## 랭킹 관련 문제

랭킹은 많이 변하지 않을 정보인데 매번 조회와 계산 과정을 거처야 하기에 비효율적일 것이라 판단된다.

위는 랭킹과 관련된 문제이다.

이 문제 해결은 조금 복잡하게 되었다.

하나 하나 천천히 살펴보자.

```java
    @Override
    public Map<Long, List<Long>> calcRankings(List<Long> memberIds, LogPeriod type) {

        Map<Long, Long> memberVisitCount = getMemberVisitCountResult(memberIds, type);

        return calculateMemberVisitCount(memberVisitCount);
    }
```

위는 기존에 랭킹을 구하는 코드이다.

이 랭킹을 구하는 코드가 rankings, memberRankingCountInfo에서 동일하게 사용된다.

즉, 동일한 계산을 하고 있는 것이다.

그렇기에 이를 NoSql인 MongoDB를 사용하고 저장해주었다.

그렇다면 파악해야하는 것이 "언제" 랭킹을 갱신해주는가 이다.

랭킹의 기준이 동방 방문 횟수이기 때문에 동방 출석 로직에서 "이벤트"를 발생하여 이를 갱신을 해주었다.

```java
@PostMapping("/entrance")
public ApiResponse<ApiResponse.withCodeAndMessage> enterClub(IpDTO ipDTO) throws IOException {
        if (!iptimeService.isInIptime(ipDTO).isIn()) {
            return ApiResponseGenerator.success(HttpStatus.OK, HttpStatus.OK.value() + "100", "enter ecnv");
        }
        Long memberId = feignUserInfo.getUserInfo(1L).getId();
        String macAddress = macAddressService.findMemberMacAddress(memberId).getMacAddress();
        try {
            iptimeService.isExistMacAddress(macAddress);
        } catch (MacAddressValidateException macAddressValidateException) {
            iptimeService.renewalList();
            iptimeService.isExistMacAddress(macAddress);
        }

        if (clubRoomLogService.save(memberId)) {
            List<Long> memberIds = macAddressService.browseMacAddressesMembers();
            applicationEventPublisher.publishEvent(new EnterClubEvent(memberIds));
        }

        return ApiResponseGenerator.success(HttpStatus.OK, HttpStatus.OK.value() + "100", "enter ecnv");
        }
```
위는 이벤트 발행 코드이다.

clubRoomLogService.save(memberId)의 반환값을 boolean으로 수정하여 이 값이 참이면 이벤트를 발행해주었다.

```java
    @Async
    @EventListener
    @Transactional
    public void calcRankings(EnterClubEvent enterClubEvent) {
        List<Long> memberIds = enterClubEvent.getMemberIds();

        saveRankings(memberIds, LogPeriod.YEAR);
        saveRankings(memberIds, LogPeriod.MONTH);
        saveRankings(memberIds, LogPeriod.WEEK);
    }
```
이벤트 헨들러는 위와 같다.

한번에 모든 타입의 랭킹을 갱신한다.

```java
    public RankingsVO getRanking(LogPeriod period) {
        return rankingsRepository.findRecent(period)
                .stream()
                .max(Comparator.comparing(RankingsVO::getLocalDateTime))
                .orElseThrow(() -> {
                    throw new IllegalStateException("no ranking result");
                });
    }
```
그렇게 저장한 값을 위와 같이 조회하여 사용한다.

System.currentTimeMillis()를 통해 간단히 측정한 속도는 기존의 로직과 큰 차이가 없기는 하였다.

하지만 그래도 이와 같이 수정하는 것이 좋겠다는 이유는 이전에는 데이터로 쌓을 수 없었지만 지금은 이를 데이터로 쌓을 수 있기 때문이다.

즉, 이전에는 하지 못했던 연간 랭킹 변화와 같은 것이 가능하다.

속도가 줄어들지 않은 것이 아쉽긴하지만 이런것이 트레이드 오프인것 같다.
