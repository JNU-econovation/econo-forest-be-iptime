## 외부 서비스 관련 문제

외부 서비스는 말그대로 외부의 서비스이기에 에러 처리에 더 신경 써주어야 한다.

우리 서비스가 사용하는 외부 서비스는 idp 서버 그리고 iptime 이다. (아직 iptime 관련 예외 문제는 고민중이다.)

기존에는 Fegin을 사용해 단순 timeout에 관한 예외만 처리해 주었다.

하지만 리펙토링을 통해 try/catch로 idp 서버의 예외를 잡아 에러 형식을 통일 시켜주었다.

더불어 idp 서버에 너무 많은 요청이 가지 않도록 redis를 통한 캐싱 처리 역시하였다.

이전에는 단순히 Fegin을 그냥 사용하였다.

하지만 이제는 아래와 같이 Fegin을 사용한다.

````java
    @Override
    public UserInfoDTO getUserByToken(String accessToken) {
        Optional<User> userByAccessToken = repository.findByAccessToken(accessToken);
        if (userByAccessToken.isPresent()) {
            return userByAccessToken.get()
                    .getUserInfoDTO(); 
        }
        
        try {
            UserInfoDTO userInfoByToken = feignUserInfo.getUserInfoByToken(accessToken);
            User user = new User(accessToken, userInfoByToken);
            repository.save(user);
            return userInfoByToken;
        } catch (Exception e) {
            throw new OuterServiceValidateException(OuterServiceException.IDP_EXCEPTION);
        }
    }
````
````java
    @Override
    public UserInfoDTO getUserById(Long userId) {
        Optional<User> userByAccessToken = repository.findByUserId(userId);
        if (userByAccessToken.isPresent()) {
            return userByAccessToken.get()
                    .getUserInfoDTO();
        }

        try {
            return feignUserInfo.getUserInfo(userId);
        } catch (Exception e) {
            throw new OuterServiceValidateException(OuterServiceException.IDP_EXCEPTION);
        }
    }
````

이전에 Fegin을 사용한 것과 달라진 것은 위에서도 언급한 듯이 `try/catch`로 예외처리를 해주었다는 것이다.


예외처리에 관해서는 이정도 알아보고 이제 캐싱을 어떻게 수행하였는지 알아보자.

```java
public class User {

    private static final Long DEFAULT_TTL = 30L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private String id;

    @Indexed
    private String accessToken;

    private UserInfoDTO userInfoVO;

    @Indexed
    private Long userId;


    @TimeToLive
    private Long expiration = DEFAULT_TTL;
}
```
위는 redis에 저장하는 User 객체이다.

살펴볼 부분은 `@TimeToLive`이다.

`Long DEFAULT_TTL = 30L`와 같이 30초로 설정하여 매 요청마다 idp에 요청을 보내는 것을 방지하였다.

30초로 설정한 것은 기존 idp에서 제공하는 accessToken의 만료기간이 2분이기에 30초 정도면 적당할 것이라 생각하였다.

30초 만으로 iptimeAPI에는 의미가 있는 것이 iptimeAPI의 대부분의 서비스가 모에숲의 서비스에 항상 노출되는 서비스기에 요청이 많이 들어오기 때문이다.

위와 같은 처리를 통해 외부서비스의 예외처리와 너무 많은 요청을 보내는 것에 대한 문제를 해결하였다 생각한다.


### 3차

```java
@Getter
@RedisHash(value = "user")
public class User {

    private static final Long DEFAULT_TTL = 30L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private String id;

    @Indexed
    private Long userId;

    private UserInfoVO userInfoVO;

    @TimeToLive
    private Long expiration = DEFAULT_TTL;

    public User(UserInfoVO userInfoVO) {
        this.userInfoVO = userInfoVO;
        this.userId = userInfoVO.getId();
    }
}
```

우선 3차에서 가장 달라진 부분은 `accessToken`을 삭제한 것이다.

`accessToken`을 사용하여 idp에 요청하는 부분은 단순 조회하만 하는 것이 아닌 그 정보로 개인에 대한 기록을 남기는 기능을 하는 코드에 사용되기에 

캐싱을 하는 것 보다 idp에 인증요청을 보내는 것이 좋겠다는 판단을 하였다.

대신 id를 통해 idp에 조회하는 부분은 단순 조회의 경우가 많아 캐싱을 해도 괜찮을 것이라 판단하였다.