## 랭킹 관련 문제(3차)

랭킹관련 문제의 경우 3차에서 많은 변화를 겪어 따로 페이지를 준비했다.

기존 랭킹 관련 문제 해결을 보려면 다음 링크를 클릭하면 된다. ([랭킹관련 문제(1,2차)](https://github.com/JNU-econovation/econo-forest-be-iptime/blob/main/docs/problem/%EB%9E%AD%ED%82%B9%EA%B4%80%EB%A0%A8%EB%AC%B8%EC%A0%9C.md))

```java
    @Override
    @Cacheable(value = "ranking", key = "#logPeriod.type")
    public Map<Long, Long> calcRanking(LogPeriod logPeriod) {
        List<MemberVisitCountVO> memberVisitCountVOS =
            repository
                .countMemberVisitCountLocalDateBetween(
                    logPeriod.getBeforeLocalDate(),
                    LocalDate.now()
                );

        Map<Long, List<Long>> visitCountGroup = groupByVisitCount(memberVisitCountVOS);

        return RankingConverter.groupByMemberId(memberIdsRankOrderByVisitCount(visitCountGroup));
    }
```

기존과 달라진 부분은 우선 MongoDB에 랭킹을 저장하는 것이 아닌 Spring Cache를 사용하여 캐싱한다는 것이다.

MongoDB에 랭킹을 저장하면 ClubRoomLog와 정보의 중복이 생긴하고 생각하였다.

랭킹이 다른 비지니스 로직에 사용된다면 DB에 저장하는 것을 고려할 수 있지만 현재는 그렇지 않기에 캐시로 충분하겠다는 판단을 하였다.

그렇기에 `@Cacheable(value = "ranking", key = "#logPeriod.type")`를 통해 캐싱을 하였고 

```java
@Override
@Transactional
public void save(Long memberId) {
    Optional<ClubRoomLog> byMemberId =
    repository.findByMemberIdAndLocalDate(memberId, LocalDate.now());

    if (byMemberId.isEmpty()) {
        repository.save(
            new ClubRoomLog(memberId, LocalDate.now())
            );
        }

        cacheEvicts.evictRankingCache();
        cacheEvicts.evictMemberVisitCountCache();
    }
```

위와 같이 ClubRoomLog가 생성될 때는 랭킹의 변화가 있을 수 있기에 캐싱된 정보를 삭제해 주었다.

// todo
지금은 단순히 삭제만 하였는데 이후에 삭제하고 갱신하는 코드를 비동기적으로 동작할 수 있도록 코드를 수정해야겠다는 생각이 든다.


그리고 또 하나 변한 것은 반환되는 형식이다.

기존에는 `등수 : 해당 사용자 리스트` 형식으로 반환하여 주었다면 지금은 `사용자 : 등수`의 형식으로 반환하여 준다.

사용성 때문에 이러한 결정을 하였다.

`사용자 : 등수` 형식으로 반환하여 주더라도 `등수 : 사용자`의 형태로 반환되는 최종 응답으로 변화하는 것이 그렇게 어렵지 않았다.

```java
    private List<MemberRankingDTO> shuffleAndMapDTO(Map<Long, Long> membersRanking) {
        List<Long> memberIds = new ArrayList<>(membersRanking.keySet());

        List<MemberRankingDTO> memberRankingDTOS = new ArrayList<>();
        for (Long memberId : memberIds) {
            memberRankingDTOS.add(
                new MemberRankingDTO(
                    membersRanking.get(memberId),
                    userService.getUserById(memberId)
                )
            );
        }

        return memberRankingDTOS;
    }
```

그리고 랭킹은 개인 랭킹 조회를 할때도 사용된다.

그렇기에 개인 랭킹 조회도 편하게 할 수 있어야 했고 그것을 생각하여 `사용자 : 등수` 형식으로 변경하게 되었다.

그래서 아래와 같이 간단히 개인 랭킹도 조회할 수 있게 되었다.

```java
    Map<Long, Long> membersRanking =
        clubRoomLogService.calcRanking(LogPeriod.valueOf(period.toUpperCase()));

    Long memberRanking = membersRanking.get(user.getId());
```