## 출석 관련 문제

기존에 출석 로직은 아래와 같다.
+ 1,2차
```java
    @PostMapping("/entrance")
    public ApiResponse<ApiResponse.withCodeAndMessage> enterClub(IpDTO ipDTO, @RequestHeader(value = "Authorization") String accessToken) {
        if (!iptimeService.isInIptime(ipDTO)
        .isIn()) {
        return ApiResponseGenerator.success(HttpStatus.OK, HttpStatus.OK.value() + "100", "enter ecnv");
        }
        Long memberId = feignUserInfo.getUserInfoByToken(accessToken).getId();
        iptimeService.isExistMacAddress(macAddressService.findMemberMacAddress(memberId).getMacAddress());
        clubRoomLogService.save(memberId);
        return ApiResponseGenerator.success(HttpStatus.OK, HttpStatus.OK.value() + "100", "enter ecnv");
    }
```

그리고 문제가 되는 부분이 iptime의 MAC 주소 리스트와 관련한 부분인데 이를 갱신하는 부분의 코드는 아래와 같다.

+ 1,2차
```java
    @Scheduled(fixedDelay = 3000)
    public void renewalList() throws IOException {
        List<String> latestMacAddressesList = this.getMacAddressesList();
        if (!macAddressesList.equals(latestMacAddressesList)) {
            this.macAddressesList = latestMacAddressesList;
        }
    }

    public List<String> getMacAddressesList() throws IOException {
        List<String> list = iptime.getList(cookieValue);
        if (!list.isEmpty()) {
            return list;
        }
        this.cookieValue = iptime.getCookieValue();
        return iptime.getList(cookieValue);
    }
```

위의 코드의 문제는 다음과 같다.

우선 갱신된 MAC 주소가 서버에 반영되기 이전에 조회를 할 가능성이 있다.


이러한 문제 때문에 아래와 같이 코드를 수정하였다.

+ 1,2차

```java
    @PostMapping("/entrance")
    public ApiResponse<ApiResponse.withCodeAndMessage> enterClub(IpDTO ipDTO, @RequestHeader(value = "Authorization") String accessToken) throws IOException {
        if (!iptimeService.isInIptime(ipDTO)
        .isIn()) {
        return ApiResponseGenerator.success(HttpStatus.OK, HttpStatus.OK.value() + "100", "enter ecnv");
        }
        Long memberId = feignUserInfo.getUserInfoByToken(accessToken).getId();
        String macAddress = macAddressService.findMemberMacAddress(memberId).getMacAddress();
        try {
            iptimeService.isExistMacAddress(macAddress);
        } catch (MacAddressValidateException macAddressValidateException) {
            iptimeService.renewalList();
            iptimeService.isExistMacAddress(macAddress);
        }
        clubRoomLogService.save(memberId);
        return ApiResponseGenerator.success(HttpStatus.OK, HttpStatus.OK.value() + "100", "enter ecnv");
    }
```

수정된 부분은 try/catch 부분으로 만약에 출석시 MAC 주소가 없다는 `MacAddressValidateException`이 발생하면 `iptimeService.renewalList()`를 통해 MAC 주소를 갱신한 이후에 다시 한번 MAC 주소 존재 여부를 확인한다.

이때 MAC 주소가 없다면 예외 경우이기 때문에 예외를 내려보낸다.

### 3차 수정 반영

+ 3차

```java
    @PostMapping("/entrance")
    public ApiResponse<ApiResponse.withCodeAndMessage> enterClub(
        IpDTO ipDTO,
        @RequestHeader(value = "Authorization") String accessToken
    )
        throws IOException {
    
        if (!iptimeService
            .isInIptime(ipDTO)
            .isIn()
        ) {
            return
                ApiResponseGenerator.success(
                    HttpStatus.OK,
                    HttpStatus.OK.value() + "100",
                    "enter ecnv"
                );
        }
    
        Long memberId =
            userServiceImpl
                .getUserByToken(accessToken)
                .getId();
    
        iptimeMacAddressFacade.validateExistMemberMacAddress(memberId);
    
        clubRoomLogService.save(memberId);
    
        return
            ApiResponseGenerator.success(
                HttpStatus.OK,
                HttpStatus.OK.value() + "100",
                "enter ecnv"
            );
    }
```



```java
    @Override
    public void isExistMacAddress(String macAddress) throws IOException {
        try {
            isContain(macAddress);
        } catch (MacAddressValidateException macAddressValidateException) {
           this.renewalList();
           this.isContain(macAddress);
        }
    }
    
    @Scheduled(fixedDelay = 3000)
    public void renewalList() throws IOException {
        List<String> latestMacAddressesList = this.getIptimeMacAddressList();

        IptimeMacAddressLists currentIptimeMacAddressList = getCurrentIptimeMacAddressList();

        if (!currentIptimeMacAddressList.isSameMacAddressList(latestMacAddressesList)) {
            IptimeMacAddressLists iptimeMacAddressLists =
                new IptimeMacAddressLists(
                    serviceIp,
                    latestMacAddressesList
                );
            repository.deleteAll();
            
            repository.save(iptimeMacAddressLists);
        }
    }

    private IptimeMacAddressLists getCurrentIptimeMacAddressList() {
        return repository.findByIp(serviceIp)
        .orElseGet(() -> {
        try {
        return new IptimeMacAddressLists(serviceIp, this.getIptimeMacAddressList());
        } catch (IOException e) {
        throw new RuntimeException(e);
        }
        });
        }
```

3차의 코드가 기존가 달라진 부분은 

schedule에 따라 iptime에서 조회해온 Mac 주소 리스트를 비교하는 대상은 ``this.macAddressesList``에서 `getCurrentIptimeMacAddressList()`를 통해 redis에서 조회한 값이라는 점

그리고 `iptimeMacAddressFacade.validateExistMemberMacAddress(memberId)`로 기존에 iptimeService와 MacAddressService가 Controller에서 같이 사용되는 것을 facade로 묶어 주었다.